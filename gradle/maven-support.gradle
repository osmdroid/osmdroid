import java.lang.invoke.MethodHandleImpl
import java.lang.reflect.Method
import java.util.concurrent.TimeUnit

/**=================================================================================================
 * Common Gradle script configuration for Maven tasks.
 *
 * @author Chris Doyle
 =================================================================================================*/


apply plugin: 'maven'
apply plugin: 'maven-publish'


// Maven Repository (i.e. Sonatype Nexus Repository Manager) Configuration -------------------------

ext.isReleaseBuild = (!project.version.equals("unspecified") &&
        project.version.contains("SNAPSHOT") == false)


project.ext.artifacts = new LinkedList<Container>();
project.ext.pgpSearch =false;
project.ext.pgpAvailable=false;
project.ext.pomAdded=false;


def dumpTasks(TaskExecutionGraph graph){
    List<Task> allTasks = graph.getAllTasks();
    for (int i=0; i < allTasks.size(); i++){
        System.out.println("TASK DUMP " + allTasks.get(i).name);
    }

}

def furyHasTask(TaskExecutionGraph graph, String task){
    List<Task> allTasks = graph.getAllTasks();
    for (int i=0; i < allTasks.size(); i++){
        if (allTasks.get(i).name.endsWith(task))
            return true;
    }
    return false;

}

ext.gpgPath = (
        hasProperty('GPG_PATH')
                ? GPG_PATH
                : "/usr/local/bin/gpg"
    //TODO maybe a defaut path for windows?
);

ext.gpgPassphrase = (
       hasProperty('GPG_PASSPHRASE')
               ? GPG_PASSPHRASE
               : ""
);

// default to Maven Central if not provided
ext.releaseRepositoryUrl = (
        hasProperty('RELEASE_REPOSITORY_URL')
                ? RELEASE_REPOSITORY_URL
                : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
)

// default to Maven Central if not provided
ext.snapshotRepositoryUrl = (
        hasProperty('SNAPSHOT_REPOSITORY_URL')
                ? SNAPSHOT_REPOSITORY_URL
                : "https://oss.sonatype.org/content/repositories/snapshots/"
)

ext.targetRepositoryUrl = ( isReleaseBuild ? releaseRepositoryUrl : snapshotRepositoryUrl)

ext.nexusUsername = ( hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : "" )
ext.nexusPassword = ( hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : "" )


// Maven POM Properties ----------------------------------------------------------------------------

// The following property definitions are consumed by the maven-publish plugin to drive automatic
// Maven POM generation. The associated configuration properties should be defined in the standard
// gradle.properties file in the root of the project.  These standard properties have been
// purposefully externalized to allow for configuration on a per-project basis without requiring
// modification to this script.
//
// NOTE: Ultimately, this work should be refactored and cleaned up for inclusion into an existing or
// new formal Gradle plugin!  (A "labor of love" task for another day on my own time...)

def licenses = []

// parse the license list
if (hasProperty("pom.licenses.license.0.name")) {

    // parse the roles of each developer
    for (def i = 0; hasProperty("pom.licenses.license.${i}.name"); ++i) {

        def license = [
                name: project.property("pom.licenses.license.${i}.name"),
                url         : (
                        hasProperty("pom.licenses.license.${i}.url")
                                ? project.property("pom.licenses.license.${i}.url") : ""
                ),
                distribution: (
                        hasProperty("pom.licenses.license.${i}.distribution")
                                ? project.property("pom.licenses.license.${i}.distribution") : ""
                )
        ]

        licenses[i] = license
    }
}

def developers = []

// parse the developer list
if (hasProperty("pom.developers.developer.0.id")) {

    // parse the roles of each developer
    for (def i = 0; hasProperty("pom.developers.developer.${i}.id"); ++i) {

        def roles = []

        if (hasProperty("pom.developers.developer.${i}.role.0")) {
            for (def j = 0; hasProperty("pom.developers.developer.${i}.role.${j}"); ++j) {
                roles[j] = project.property("pom.developers.developer.${i}.role.${j}")
            }
        }

        def developer = [
                id: project.property("pom.developers.developer.${i}.id"),
                name: (
                        hasProperty("pom.developers.developer.${i}.name")
                                ? project.property("pom.developers.developer.${i}.name") : ""
                ),
                email: (
                        hasProperty("pom.developers.developer.${i}.email")
                                ? project.property("pom.developers.developer.${i}.email") : ""
                ),
                organization: (
                        hasProperty("pom.developers.developer.${i}.organization")
                                ? project.property("pom.developers.developer.${i}.organization") : ""
                ),
                roles: roles
        ]

        developers[i] = developer
    }
}


// now we define the primary "pom" configuration used by the maven-publish plugin (see below)
ext.pom = [
        packaging: ( hasProperty('pom.packaging') ? project.property('pom.packaging') : "jar" ), // use JAR as the default ???
        name: ( hasProperty('project.name') ? project.property('project.name') : "" ),
        description: ( hasProperty('project.description') ? project.property('project.description') : "" ),
        url: ( hasProperty('pom.url') ? project.property('pom.url') : "" ),
        inceptionYear: ( hasProperty('pom.inceptionYear') ? project.property('pom.inceptionYear') : "" ),
        licenses: licenses,
        organization: [
                name: ( hasProperty('pom.organization.name') ? project.property('pom.organization.name') : "" ),
                url: ( hasProperty('pom.organization.url') ? project.property('pom.organization.url') : "" )
        ],
        developers: developers,
        issueManagement: [
                system: (
                        hasProperty('pom.issueManagement.system') ? project.property('pom.issueManagement.system') : ""
                ),
                url: ( hasProperty('pom.issueManagement.url') ? project.property('pom.issueManagement.url') : "" )
        ],
        ciManagement: [
                system: ( hasProperty('pom.ciManagement.system') ? project.property('pom.ciManagement.system') : "" ),
                url: ( hasProperty('pom.ciManagement.url') ? project.property('pom.ciManagement.url') : "" )
        ],
        scm: [
                url: ( hasProperty('pom.scm.url') ? project.property('pom.scm.url') : "" ),
                connection: ( hasProperty('pom.scm.connection') ? project.property('pom.scm.connection') : "" ),
                developerConnection: (
                        hasProperty('pom.scm.developerConnection')
                                ? project.property('pom.scm.developerConnection') : ""
                )
        ],
        distributionManagement: [
                site: [
                        id: (
                                hasProperty('pom.distributionManagement.site.id')
                                        ? project.property('pom.distributionManagement.site.id') : ""
                        ),
                        url: ( hasProperty('pom.distributionManagement.site.url')
                                ? project.property('pom.distributionManagement.site.url') : ""
                        )
                ]
        ]
]


// Gradle Execution Pipeline Hacks -----------------------------------------------------------------

// And here's where we muck with the Gradle task execution pipeline in order to strong-arm the
// proper publishing of all artifacts (for every Android build variant) to a target Maven repository
// (e.g. Sonatype Nexus)
//
// For background information regarding this "neat" series of hacks, please visit the following
// thread from the Gradle forums:
//
//     "How can I upload multiple flavors/artifacts with different POM-files using mavenDeployer?"
//     https://discuss.gradle.org/t/how-can-i-upload-multiple-flavors-artifacts-with-different-pom-files-using-mavendeployer/5887

build.mustRunAfter clean
publish.dependsOn build

uploadArchives.dependsOn publish

uploadArchives {
    doFirst {
        //execution phase
        println "\n\n========================================================="
        println "==> WARNING: The 'uploadArchives' task is deprecated. <=="
        println "==> Calling the 'publish' task instead...             <=="
        println "=========================================================\n\n"

        throw new StopExecutionException("Calling the 'publish' task instead...")
    }
}


afterEvaluate { project ->


    project.ext.isJavaProject = project.plugins.hasPlugin('java');
    project.ext.isWarProject = project.plugins.hasPlugin('war');

    // FIXME :: @chrisdoyle :: DRY :: these are also defined in android-support.gradle...
    project.ext.isAndroidApplication = project.plugins.hasPlugin("com.android.application");
    project.ext.isAndroidLibrary = project.plugins.hasPlugin("com.android.library");
    project.ext.isAndroidProject = project.isAndroidApplication || project.isAndroidLibrary;


    // Digitally sign all Release artifacts --------------------------------------------------------

    // NOTE: For now the only "validation" we will perform is whether or not a value is provided for
    // each of the required signingConfigs properties.  More concrete validation may be developed as
    // an enhancement in the future, if desired.
    ext.canSign = project.hasProperty('android.signingConfigs.release.storeFile') &&
            (project.property('android.signingConfigs.release.storeFile') != null) &&
            !project.property('android.signingConfigs.release.storeFile').trim().isEmpty() &&
            project.hasProperty('android.signingConfigs.release.storePassword') &&
            (project.property('android.signingConfigs.release.storePassword') != null) &&
            !project.property('android.signingConfigs.release.storePassword').trim().isEmpty() &&
            project.hasProperty('android.signingConfigs.release.keyAlias') &&
            (project.property('android.signingConfigs.release.keyAlias') != null) &&
            !project.property('android.signingConfigs.release.keyAlias').trim().isEmpty() &&
            project.hasProperty('android.signingConfigs.release.keyPassword') &&
            (project.property('android.signingConfigs.release.keyPassword') != null) &&
            !project.property('android.signingConfigs.release.keyPassword').trim().isEmpty();

    // END Digitally sign all Release artifacts ----------------------------------------------------


    // (Yet Another) Gradle Execution Pipeline Hack (to override the inoperable 'install' task for
    // Android projects!!!
    if (project.ext.isJavaProject) {
        install {
            doFirst {
                println "\n\n========================================================="
                println "==> WARNING: The 'install' task is deprecated.        <=="
                println "==> Calling the 'publishToMavenLocal' task instead... <=="
                println "=========================================================\n\n"

                throw new StopExecutionException("Calling the 'publishToMavenLocal' task instead...")
            }
        }

        install.dependsOn publishToMavenLocal
    }
    else if (project.ext.isAndroidProject) {
        task install() {
            doFirst {
                println "\n\n========================================================="
                println "==> WARNING: The 'install' task is deprecated.        <=="
                println "==> Calling the 'publishToMavenLocal' task instead... <=="
                println "=========================================================\n\n"

                throw new StopExecutionException("Calling the 'publishToMavenLocal' task instead...")
            }
        }

        install.dependsOn publishToMavenLocal

        build.mustRunAfter clean
        publishToMavenLocal.dependsOn build
    }

    if (project.hasProperty('profile')) {
        project.ext.profiles = project.profile.split(',')

        project.ext.set("ciProfileEnabled", project.ext.profiles.contains("ci"));

        project.ext.set("javadocProfileEnabled", project.ext.profiles.contains("javadoc")
                || project.ciProfileEnabled);

        project.ext.set("sourcesProfileEnabled", project.ext.profiles.contains("sources")
                || project.ciProfileEnabled);

        project.ext.set("sign", project.ext.profiles.contains("sign"));
    }
    else {
        project.ext.set("ciProfileEnabled", false);
        project.ext.set("javadocProfileEnabled", false);
        project.ext.set("sourcesProfileEnabled", false);
        project.ext.set("sign", false);
    }

    if (project.isJavaProject) {
        if (project.javadocProfileEnabled) {
            javadoc {
                classpath = configurations.compile

                options.charSet 'UTF-8'
                options.docEncoding 'UTF-8'
                options.encoding 'UTF-8'
                //options.addStringOption('Xdoclint:none', '-quiet')
                //classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
                failOnError false

                // FIXME :: @chrisdoyle :: this assumes Java 7...
                options.links 'http://docs.oracle.com/javase/7/docs/api/'
                options.links("http://developer.android.com/reference/");

                options {
                    setMemberLevel(JavadocMemberLevel.PACKAGE)
                }
            }

            task javadocJar(type: Jar, dependsOn: javadoc) {
                classifier = 'javadoc'
                from javadoc.destinationDir
            }
        }

        if (project.sourcesProfileEnabled) {
            task sourcesJar(type: Jar, dependsOn: classes) {
                classifier = 'sources'
                from sourceSets.main.allSource
            }
        }
    }
    else if (project.isAndroidProject) {
        def variants

        if (project.android.hasProperty('libraryVariants')) {
            variants = project.android.libraryVariants;
        }
        else if (project.android.hasProperty('applicationVariants')) {
            variants = project.android.applicationVariants;
        }

        variants.all { variant ->
            def artifactName = project.name + "-" + project.version + "-" + variant.name + "." +
                    project.pom.packaging;

            if (project.javadocProfileEnabled) {
                project.task("${variant.name}Javadoc", type: Javadoc) {

                    // https://github.com/chrisbanes/gradle-mvn-push/issues/9
                    failOnError false

                    destinationDir = new File("$project.buildDir/javadoc/$variant.name")

                    source = variant.javaCompile.source

                    classpath = project.files(variant.javaCompile.classpath.files)

                    if ("${project.android.compileSdkVersion}".contains("Google")){
                        System.out.println("applying google maps for javadocs ${project.android.compileSdkVersion}")
                        classpath += project.files("${project.android.sdkDirectory}/add-ons/addon-google_apis-google-23/libs/maps.jar")
                        classpath += project.files("${project.android.sdkDirectory}/add-ons/addon-google_apis-google-23/libs/effects.jar")
                        classpath += project.files("${project.android.sdkDirectory}/add-ons/addon-google_apis-google-23/libs/usb.jar")

                    }
                    ext.androidJar =
                                "${project.android.sdkDirectory}/platforms/${project.android.compileSdkVersion}/android.jar"

                    classpath += project.files(ext.androidJar)
                    // other lame attempts to overcome the 3-headed monster...
//                      classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
//                      classpath += variants.toList().first().javaCompile.classpath

                    options {
                        links "http://docs.oracle.com/javase/7/docs/api/"
                        linksOffline("http://d.android.com/reference",
                                "${project.android.sdkDirectory}/docs/reference")
                        setMemberLevel(JavadocMemberLevel.PACKAGE)
                        docEncoding = 'UTF-8'
                        encoding = 'UTF-8'
                        charSet = 'UTF-8'
                    }

                    exclude '**/BuildConfig.java'
                    exclude '**/R.java'
                }

                project.task("generate${variant.name.capitalize()}JavadocJar", type: Jar,
                        dependsOn: "${variant.name}Javadoc") {

                    classifier "${variant.name}-javadoc"

                    description = 'Assembles a JAR archive containing the generated Javadoc API documentation of $variant.name.'

                    exclude '**/BuildConfig.class'
                    exclude '**/R.class'

                    from "$project.buildDir/javadoc/$variant.name"
                }
            }

            if (project.sourcesProfileEnabled) {
                project.task("generate${variant.name.capitalize()}SourcesJar", type: Jar) {
                    classifier = "${variant.name}-sources"

                    description = 'Assembles a JAR archive containing the main sources of $variant.name.'

                    // exclude generated files
                    exclude '**/BuildConfig.java'
                    exclude '**/R.java'

                    from variant.javaCompile.source
                }
            }
        }
    }
}


def modifyGeneratedPom(pom) {
    pom.withXml { provider ->
        def node = provider.asNode()

        if (!project.pom.packaging.equals("")) {
            if (!node.packaging) {
                node.appendNode('packaging', project.pom.packaging)
            }
            else {
                node.packaging.replaceNode {
                    packaging(project.pom.packaging)
                }
            }
        }
        else {
            println "No pom.packaging defined in gradle.properties"
        }


        //fix for issue #27 name element missing from pom
        if ("".equals(project.pom.name)){
            project.pom.name = project.getName();
        }

        if (!project.pom.name.equals("")) {
            if (!node.name) {
                node.appendNode('name', project.pom.name)
            }
            else {
                node.name.replaceNode {
                    name(project.pom.name)
                }
            }
        }

        //fix for issue #27 description element missing from pom
        if ("".equals(project.pom.description)){
            project.pom.description = project.getDescription();
        }
        //a description is mandatory for mavenCentral, this injects a placeholder
        if ("".equals(project.pom.description)){
            project.pom.description = "A description should be added in the near future, as soon as I hack time.";
        }

        if (!project.pom.description.equals("")) {
            if (!node.description) {
                node.appendNode('description', project.pom.description)
            }
            else {
                node.description.replaceNode {
                    description( project.pom.description )
                }
            }
        }

        if (!project.pom.url.equals("")) {
            if (!node.url) {
                node.appendNode('url', project.pom.url)
            }
            else {
                node.url.replaceNode {
                    url(project.pom.url)
                }
            }
        }

        if (!project.pom.inceptionYear.equals("")) {
            if (!node.url) {
                node.appendNode('inceptionYear', project.pom.inceptionYear)
            }
            else {
                node.url.replaceNode {
                    inceptionYear(project.pom.inceptionYear)
                }
            }
        }

        def licenses = project.pom.licenses

        if ((licenses != null) && (licenses.size() > 0)) {
            def licensesNode = node.appendNode('licenses')

            licenses.each {
                def licenseNode = licensesNode.appendNode('license')

                if ((it.name != null) && !it.name.equals("")) {
                    licenseNode.appendNode('name', it.name)
                }

                if ((it.url != null) && !it.url.equals("")) {
                    licenseNode.appendNode('url', it.url)
                }

                if ((it.distribution != null) && !it.distribution.equals("")) {
                    licenseNode.appendNode('distribution', it.distribution)
                }
            }
        }

        if (!project.pom.organization.name.equals("") || !project.pom.organization.url.equals("")) {
            def organizationNode = node.appendNode('organization')

            if (!project.pom.organization.name.equals("")) {
                organizationNode.appendNode('name', project.pom.organization.name)
            }

            if (!project.pom.organization.url.equals("")) {
                organizationNode.appendNode('url', project.pom.organization.url)
            }
        }


        def developers = project.pom.developers

        if ((developers != null) && (developers.size() > 0)) {
            def developersNode = node.appendNode('developers')

            developers.each {
                def developerNode = developersNode.appendNode('developer')

                if ((it.id != null) && !it.id.equals("")) {
                    developerNode.appendNode('id', it.id)
                }

                if ((it.name != null) && !it.name.equals("")) {
                    developerNode.appendNode('name', it.name)
                }

                if ((it.email != null) && !it.email.equals("")) {
                    developerNode.appendNode('email', it.email)
                }

                if ((it.organization != null) && !it.organization.equals("")) {
                    developerNode.appendNode('organization', it.organization)
                }

                if ((it.roles != null) && (it.roles.size() > 0)) {
                    def rolesNode = developerNode.appendNode('roles')
                    it.roles.each {
                        rolesNode.appendNode('role', it)
                    }
                }
            }
        }

        if (!project.pom.issueManagement.system.equals("")
                || !project.pom.issueManagement.url.equals("")) {

            def issueManagementNode = node.appendNode('issueManagement')

            if (!project.pom.issueManagement.system.equals("")) {
                issueManagementNode.appendNode('system', project.pom.issueManagement.system)
            }
            if (!project.pom.issueManagement.url.equals("")) {
                issueManagementNode.appendNode('url', project.pom.issueManagement.url)
            }
        }

        if (!project.pom.ciManagement.system.equals("")
                || !project.pom.ciManagement.url.equals("")) {
            def ciManagementNode = node.appendNode('ciManagement')

            if (!project.pom.ciManagement.system.equals("")) {
                ciManagementNode.appendNode('system', project.pom.ciManagement.system)
            }
            if (!project.pom.ciManagement.url.equals("")) {
                ciManagementNode.appendNode('url', project.pom.ciManagement.url)
            }
        }

        if (!project.pom.scm.url.equals("") || !project.pom.scm.connection.equals("")
                || !project.pom.scm.developerConnection.equals("")) {
            def scmNode = node.appendNode('scm')

            if (!project.pom.scm.url.equals("")) {
                scmNode.appendNode('url', project.pom.scm.url)
            }
            if (!project.pom.scm.connection.equals("")) {
                scmNode.appendNode('connection', project.pom.scm.connection)
            }
            if (!project.pom.scm.developerConnection.equals("")) {
                scmNode.appendNode('developerConnection', project.pom.scm.developerConnection)
            }
        }

        if (!project.pom.distributionManagement.site.id.equals("")
                || !project.pom.distributionManagement.site.url.equals("")) {
            def distributionManagementNode = node.appendNode('distributionManagement')
            def siteNode = distributionManagementNode.appendNode('site')

            if (!project.pom.distributionManagement.site.id.equals("")) {
                siteNode.appendNode('id', project.pom.distributionManagement.site.id)
            }
            if (!project.pom.distributionManagement.site.url.equals("")) {
                siteNode.appendNode('url', project.pom.distributionManagement.site.url)
            }
        }
        if (project.isAndroidProject) {

            // modified from "Gradle not including dependencies in published pom.xml"
            // http://stackoverflow.com/a/32451846/3093897
            def dependenciesNode = asNode().appendNode('dependencies')
            def configurationNames = ['compile'] // FIXME :: Issue #21: POM dependency generation shall support type and scope

            configurationNames.each { configurationName ->
                configurations[configurationName].allDependencies.each { dependency ->
                    if (dependency.group != null && dependency.name != null) {

                        def dependencyNode = dependenciesNode.appendNode('dependency')
                        dependencyNode.appendNode('groupId', dependency.group)
                        dependencyNode.appendNode('artifactId', dependency.name)
                        if (dependency.version.endsWith("+")){
                            //a gradle wildcard
                            if ("+".equals(dependency.version)) {
                                dependencyNode.appendNode('version', "LATEST")
                            } else {
                                //the version is something.+
                                dependencyNode.appendNode('version', "[" + dependency.version.replace(".+",",)")  )
                            }
                            //TODO there may be other cases here

                        }
                        else {
                            dependencyNode.appendNode('version', dependency.version)
                        }

// FIXME :: Issue #21: POM dependency generation shall support type and scope
//                        dependencyNode.appendNode('type', ???)
//                        dependencyNode.appendNode('scope', configurationName) // ???

                        // if there are any exclusions in dependency
                        if (dependency.excludeRules.size() > 0) {
                            def exclusionsNode = dependencyNode.appendNode('exclusions')
                            it.excludeRules.each { rule ->
                                def exclusionNode = exclusionsNode.appendNode('exclusion')
                                exclusionNode.appendNode('groupId', rule.group)
                                exclusionNode.appendNode('artifactId', rule.module)
                            }
                        }
                    }
                }
            }
        }
        //reflect(pom);
    }
}


// maven-publish Configuration (I love me some incubation!!!) --------------------------------------
//
// =====================================================================================
// ==> COMMENTARY: Gradle is wackadoodle. (Or perhaps it's just my understanding...) <==
// =====================================================================================
//
// In order to avoid:
//
//      > Cannot configure the 'publishing' extension after it has been accessed.
//
// I had to steal some voodoo from here:
//
//      http://stackoverflow.com/a/27066692/3093897
//
// I have a vague idea what it does, but at the end of the day I don't really care as long as it
// freaking works.  It is absurd having to write non-standard Groovy code to support standard
// lifecycle operations, the least of which is artifact publishing.
//
// --Doyle
//

//Note: this block fires BEFORE the taskGraph is ready :(
project.plugins.withType(MavenPublishPlugin) {
    project.extensions.configure PublishingExtension,
            new org.gradle.api.internal.ClosureBackedAction( {

        publications {
            //TODO WAR projects
             if (project.isJavaProject) {
                def artifactName = project.name + "-" + project.version + "." + project.pom.packaging;
                def artifactRoot = "${buildDir}/libs/"

                javaArtifacts(MavenPublication) {
                    from components.java

                    groupId project.group
                    artifactId project.name
                    version project.version

                    modifyGeneratedPom(pom)

                    //the jar
                    Container c;
                    c = new Container();
                    c.buildDir ="${buildDir}";
                    c.fileName = artifactName;
                    c.fileNameAndPath = "${artifactRoot}${artifactName}";
                    c.type="jar";
                    project.ext.artifacts.add(c);
                    logger.debug("Adding " + "${artifactRoot}${artifactName}" + " to artifact list");


                    if (isGPGAvailable()){
                        logger.debug("Adding " + c.fileNameAndPath + ".asc" + " to artifact list");
                        artifact(c.fileNameAndPath + ".asc") {
                            extension 'jar.asc'
                        }
                    }


                    //the pom
                    c = new Container();
                    c.buildDir ="${buildDir}";
                    c.fileName = artifactName;
                    c.fileNameAndPath = "$buildDir/publications/javaArtifacts/pom-default.xml";
                    c.type="jar";
                    project.ext.artifacts.add(c);
                    logger.debug("Adding " + "$buildDir/publications/javaArtifacts/pom-default.xml" + " to artifact list");


                    if (isGPGAvailable()){
                        logger.debug("Adding " + c.fileNameAndPath + ".asc" + " to artifact list");
                        artifact(c.fileNameAndPath + ".asc") {
                            extension 'pom.asc'
                        }
                    }
                }

                if (project.javadocProfileEnabled) {
                    javadocArtifacts(MavenPublication) {
                        from components.java

                        groupId project.group
                        artifactId project.name
                        version project.version

                        modifyGeneratedPom(pom)

                        artifact javadocJar


                        Container c;
                        c = new Container();
                        c.buildDir ="${buildDir}";
                        c.fileName = artifactName;
                        c.fileNameAndPath = "${buildDir}" +"/libs/" + project.name + "-" + project.version + "-javadoc.jar";
                        c.type="jar";
                        project.ext.artifacts.add(c);
                        logger.debug("Adding " + "${buildDir}" +"/libs/" + project.name + "-" + project.version + "-javadoc.jar" + " to artifact list");


                        if (isGPGAvailable()){
                            logger.debug("Adding " + c.fileNameAndPath + ".asc" + " to artifact list");
                            artifact(c.fileNameAndPath + ".asc") {
                                extension project.pom.packaging
                                classifier "javadoc"
                                extension 'asc'
                            }
                        }


                    }
                }

                if (project.sourcesProfileEnabled) {
                    sourceJarArtifacts(MavenPublication) {
                        from components.java

                        groupId project.group
                        artifactId project.name
                        version project.version

                        modifyGeneratedPom(pom)

                        artifact sourcesJar

                        Container c;
                        c = new Container();
                        c.buildDir ="${buildDir}";
                        c.fileName = artifactName;
                        c.fileNameAndPath = "${buildDir}" +"/libs/" + project.name + "-" + project.version + "-sources.jar";
                        c.type="jar";
                        project.ext.artifacts.add(c);
                        logger.debug("Adding " + "${buildDir}" +"/libs/" + project.name + "-" + project.version + "-sources.jar" + " to artifact list");


                        if (isGPGAvailable()){
                            logger.debug("Adding " + c.fileNameAndPath + ".asc" + " to artifact list");
                            artifact(c.fileNameAndPath + ".asc") {
                                extension project.pom.packaging
                                classifier "sources"
                                extension 'asc'
                            }
                        }
                    }
                }
            }
            else if (project.isAndroidProject) {
                def artifactRoot
                def variants

                if (project.android.hasProperty('applicationVariants')) {
                    artifactRoot = "${buildDir}/outputs/apk"
                    variants = project.android.applicationVariants;
                }
                else if (project.android.hasProperty('libraryVariants')) {
                    artifactRoot = "${buildDir}/outputs/aar"
                    variants = project.android.libraryVariants;
                }


                androidArtifacts(MavenPublication) {
                    groupId project.group
                    artifactId project.name
                    version project.version

                    modifyGeneratedPom(pom)

                    variants.all { variant ->

                        if (!variant.name.toLowerCase().endsWith("release")
                                || (variant.name.toLowerCase().endsWith("release") && canSign)) {


                            def artifactName = project.name + "-" + project.version + "-" +
                                    variant.name + "." + project.pom.packaging;
                            def artifactPrefix = project.name + "-" + project.version + "-" +
                                    variant.name;

                            //signs the pom
                            Container c = new Container();
                            c.fileName = variant.name + ".pom";
                            c.fileNameAndPath = "${artifactRoot}/${artifactName}.pom";
                            c.buildDir = "${buildDir}";
                            if (project.isAndroidApplication)
                                c.type = "apk";
                            else c.type = "aar";
                            project.ext.artifacts.add(c);



                            if (!project.ext.pomAdded) {
                                //this check prevents failures because the pom is generated multiple times,
                                //mostly because of variants and debug/release
                                project.ext.pomAdded = true;

                                if (isGPGAvailable()) {
                                    logger.debug("Adding " + "${buildDir}/publications/androidArtifacts/pom-default.xml.asc" + ".asc" + " to artifact list");
                                    artifact("${buildDir}/publications/androidArtifacts/pom-default.xml.asc") {
                                        extension "asc"
                                        classifier "pom"
                                    }
                                }
                            }

                            //signs the actual output
                            c = new Container();
                            if (project.isAndroidApplication)
                                c.type = "apk";
                            else c.type = "aar";
                            c.buildDir = "${buildDir}";
                            c.fileName = variant.name;
                            c.fileNameAndPath = "${artifactRoot}/${artifactName}";
                            project.ext.artifacts.add(c);


                            logger.debug("Adding " + "${artifactRoot}/${artifactName}" + " to artifact list");
                            artifact("${artifactRoot}/${artifactName}") {
                                classifier variant.name
                                extension project.pom.packaging
                            }


                            if (isGPGAvailable()) {
                                logger.debug("Adding " + "${artifactRoot}/${artifactName}" + ".asc" + " to artifact list");
                                artifact("${artifactRoot}/${artifactName}" + ".asc") {
                                    classifier c.fileName
                                    extension project.pom.packaging + '.asc'
                                }
                            }





                            if (project.javadocProfileEnabled) {
                                artifact tasks["generate${variant.name.capitalize()}JavadocJar"]
                                logger.debug("Adding " + "${buildDir}/libs/${artifactPrefix}-javadoc.jar" + " to artifact list");
                                c = new Container();
                                if (project.isAndroidApplication)
                                    c.type = "apk";
                                else c.type = "aar";
                                c.buildDir = "${buildDir}";
                                c.fileName = variant.name;
                                c.fileNameAndPath = "${buildDir}/libs/${artifactPrefix}-javadoc.jar";
                                //c.artifact=publications;
                                project.ext.artifacts.add(c);

                                if (isGPGAvailable()) {
                                    logger.debug("Adding " + "${artifactRoot}/${artifactName}" + ".asc" + " to artifact list");
                                    artifact("${artifactRoot}/${artifactName}" + ".asc") {
                                        extension project.pom.packaging
                                        classifier c.fileName + "-javadoc"
                                        extension 'asc'
                                    }
                                }


                            }

                            if (project.sourcesProfileEnabled) {
                                artifact tasks["generate${variant.name.capitalize()}SourcesJar"]
                                c = new Container();
                                if (project.isAndroidApplication)
                                    c.type = "apk";
                                else c.type = "aar";
                                c.buildDir = "${buildDir}";
                                c.fileName = variant.name;
                                c.fileNameAndPath = "${buildDir}/libs/${artifactPrefix}-sources.jar";
                                project.ext.artifacts.add(c);

                                logger.debug("Adding " + "${buildDir}/libs/${artifactPrefix}-sources.jar" + " to artifact list");

                                if (isGPGAvailable()) {
                                    artifact("${artifactRoot}/${artifactName}" + ".asc") {
                                        extension project.pom.packaging
                                        classifier c.fileName + "-sources"
                                        extension 'asc'
                                    }
                                }
                            }
                        }

                    }
                }
            }
        }

        if (!"".equalsIgnoreCase(project.targetRepositoryUrl)){
            repositories {
                maven {
                    url project.targetRepositoryUrl

                    if (!project.nexusUsername.equals("")) {
                        credentials {
                            username project.nexusUsername
                            password project.nexusPassword
                        }
                    }
                }
            }
        }
    })
}

/**
 * Signs a file via gpg
 * @param file string path to the file
 * @return false is signing failed or gpg is not available
 */
ext.signFile =  { file ->
    logger.debug("attempting to sign " + file)
    if (!new File(file).exists()){
        logger.warn("WARN - skipping gpg signature of " + file + ", it probably hasn't been created yet!");
        return false;
    }
    File f = new File(file + ".asc");
    if (f.exists())
        f.delete();
    exec {

        executable ext.gpgPath

        args "-a", "--passphrase", ext.gpgPassphrase, "--output", file+".asc", "--detach-sig", file
        \
    }
    return true;
}

/**
 * a simple container for capturing data about a file that needs to be signed
 */
class Container{
    String fileNameAndPath;
    String fileName;
    /**
     * only used to diff pom files
     */
    String type;
    String buildDir;
}

/**
 * this bit is kind of interesting
 * when the signing code runs, it tends to run out of order, thiis part will force the signing method
 * to rerun as the rest of the project is built.
 *
 * is it unnecessary work? you bet, however the signer skips
 */
gradle.taskGraph.whenReady { taskGraph ->
    def tasks = taskGraph.getAllTasks()
    tasks.each {
        def taskName = it.getName()
        if (taskName == 'signArtifacts' || taskName == "signArtifacts2" ||
        taskName == "generatePomFileForAndroidArtifactsPublication") {
            logger.debug("Found $taskName")

            it.setOnlyIf { true }
            it.outputs.upToDateWhen { false }
        }
    }
}

/**
 * dev note: this function could possibly be used to completely override gradle's publish mechanism
 * by injecting an HTTP PUT, effectively solving the rediciously problem of not being able to specify
 * the name of the artifact when it's uploaded.
 */

task signArtifacts() << {
   // this line just makes gradle angry, left as a warn for future self
    // outputs.upToDateWhen { false }
    logger.info("Attempting to sign artifacts "  + project.ext.artifacts.size());

    Iterator<Container> myiterator = project.ext.artifacts.iterator();
    while (myiterator.hasNext()){

        Container item = myiterator.next();
        logger.debug(item.fileNameAndPath + " " + item.fileName + " " + item.type);
        if (item.fileNameAndPath.endsWith(".pom")) {
            if ("jar".equals(item.type)) {

                item.fileNameAndPath = item.buildDir + "/publications/javaArtifacts/pom-default.xml";
            }
            if ("aar".equals(item.type)) {

                item.fileNameAndPath = item.buildDir + "/publications/androidArtifacts/pom-default.xml";
            }
            if ("apk".equals(item.type)) {

                item.fileNameAndPath = item.buildDir + "/publications/androidArtifacts/pom-default.xml";
            }
        }
        if (isGPGAvailable()) {
            if (signFile(item.fileNameAndPath)) {
                logger.info(item.fileNameAndPath + " signed!");
            } else {
                logger.warn("WARN - failed to sign artifact at " - item.fileNameAndPath);
            }
        } else {
            logger.warn("GPG not available " - item.fileNameAndPath);

        }
    }
}


def reflect(object){
    Method[] bits = object.class.methods
    for (int k =0; k < bits.length; k++){
        System.out.println(bits[k].name);
        for (int x=0; x < bits[k].parameterTypes.length; x++) {
            System.out.println("\t" + bits[k].parameterTypes[x].name);
        }
    }
}

build.finalizedBy(signArtifacts)





//used to surpress output from pgp's help method
def dummyOutputStream = new OutputStream() {
    @Override
    public void write(int b) {}
}


/**
 * Attempts to call pgp --help
 * @return true if gpg is available on the system
 */
def isGPGAvailable(){
    if (!project.sign)
        return false;
    if (project.ext.pgpSearch)
        return project.ext.pgpAvailable;
    project.ext.pgpSearch=true;
    logger.debug("searching for GPG")
    try {
        exec {
            executable ext.gpgPath
            args "--help"
            standardOutput = new ByteArrayOutputStream()
            errorOutput = new ByteArrayOutputStream()
        }
        logger.debug("GPG found at " + gpgPath);
        project.ext.pgpAvailable=true;
        return true;
    }catch (Exception ex){
        ex.printStackTrace();
    }
    //TODO search commons paths for windows?
    logger.warn("GPG NOT found, signing will not be possible");
    project.ext.pgpAvailable=false;
    return false;
}


/*

Well now, you've made it to the end, below this line is exerpimental code.
 */

/*
gradle.taskGraph.beforeTask { Task task ->
    if (task.name.endsWith("publishAndroidArtifactsPublicationToMavenRepositor")) {
        System.out.println("attempting to trigger artifact signatures before publishAndroidArtifactsPublicationToMavenRepositor")
        tasks.signArtifacts2.execute()
        tasks.signArtifacts.execute()
        System.out.println("done to trigger artifact signatures before publishAndroidArtifactsPublicationToMavenRepositor")

    }
}
gradle.taskGraph.afterTask { Task task ->

    if (task.name.endsWith("generatePomFileForAndroidArtifactsPublication")){
        System.out.println("attempting to trigger artifact signatures after generatePomFileForAndroidArtifactsPublication")
        tasks.signArtifacts2.execute()
        tasks.signArtifacts.execute()
        System.out.println("done to trigger artifact signatures after generatePomFileForAndroidArtifactsPublication")

    }

}*/


/*
gradle.taskGraph.whenReady { graph ->
    List<Task> allTasks = graph.getAllTasks();
    for (int i=0; i < allTasks.size(); i++){
        if (allTasks.get(i).name.equalsIgnoreCase("publishAndroidArtifactsPublicationToMavenLocal")) {
            //signArtifacts.dependsOn(allTasks.get(i));
            //reflect(allTasks.get(i));
            allTasks.get(i) {
                System.out.println("===== injected");
                signArtifacts
               // throw new Exception("the fuck?");
            };
            System.out.println("===== injected");
        }
        if (allTasks.get(i).name.equalsIgnoreCase("generatePomFileForAndroidArtifactsPublication")){
            allTasks.get(i).mustRunAfter {
                System.out.println("===== injected");
                signArtifacts
                throw new Exception("the fuck?");
            };
        }

    }
    //build.finalizedBy(signArtifacts)
    //uploadArchives.mustRunAfter(signArtifacts)

}
*/


/*
task fury() << {
    //outputs.upToDateWhen { false }
    if (!"".equalsIgnoreCase(RELEASE_REPOSITORY_URL)){
        Iterator<Container> myiterator = project.ext.artifacts.iterator();
        while (myiterator.hasNext()) {

            Container item = myiterator.next();
            System.out.println(item.fileNameAndPath + " " + item.fileName + " " + item.type);
            if (new File(item.fileNameAndPath).exists()) {
                HttpURLConnection con = getHttpConnection(RELEASE_REPOSITORY_URL, "PUT");
                String result = null;
                try {
                    con = .getHttpConnection(url, type);
                    //you can add any request body here if you want to post
                    if (reqbody != null) {
                        con.setDoInput(true);
                        con.setDoOutput(true);
                        DataOutputStream out = new DataOutputStream(con.getOutputStream());
                        FileInputStream fis = new FileInputStream(item.fileNameAndPath);
                        byte[] buffer = new byte[1024];
                        int bits = fis.read(buffer);
                        while (bits > 0) {
                            out.writeBytes(buffer, 0, bits);
                            bits = fis.read(buffer);
                        }
                        out.flush();
                        out.close();

                    }
                    con.connect();
                    BufferedReader inBufferedReader = new BufferedReader(new InputStreamReader(con.getInputStream()));
                    String temp = null;
                    StringBuilder sb = new StringBuilder();
                    while ((temp = inBufferedReader.readLine()) != null) {
                        sb.append(temp).append(" ");
                    }
                    result = sb.toString();
                    inBufferedReader.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                    logger.error(e.getMessage());
                }
            }
        }
    }
}


public  HttpURLConnection getHttpConnection(String url, String type){
    URL uri = null;
    HttpURLConnection con = null;
    try{
        uri = new URL(url);
        con = (HttpURLConnection) uri.openConnection();
        con.setRequestMethod(type); //type: POST, PUT, DELETE, GET
        con.setDoOutput(true);
        con.setDoInput(true);
        con.setConnectTimeout(60000); //60 secs
        con.setReadTimeout(60000); //60 secs
        con.setRequestProperty("Accept-Encoding", "Your Encoding");
        con.setRequestProperty("Content-Type", "Your Encoding");
    }catch(Exception e){
        logger.info( "connection i/o failed" );
    }


    return con;
}*/