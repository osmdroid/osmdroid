package org.osmdroid.bonuspack;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Locale;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.osmdroid.util.BoundingBoxE6;
import org.osmdroid.util.GeoPoint;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;
import android.util.Log;

/** class to get a route between a start and a destination point, 
 * going through a list of waypoints. 
 * 
 * It uses MapQuest open, public and free API, based on OpenStreetMap data. 
 * @see http://open.mapquestapi.com/guidance
 * @return a "Road" object. 
 * 
 * @author M.Kergall
 */
public class MapQuestRoadManager extends RoadManager {
	
	static final String MAPQUEST_GUIDANCE_SERVICE = "http://open.mapquestapi.com/guidance/v0/route?";
	
	/**
	 * Build the URL to MapQuest service returning a route in XML format
	 * @param waypoints: array of waypoints, as [lat, lng], from start point to end point. 
	 */
	protected String getUrl(ArrayList<GeoPoint> waypoints) {
		StringBuffer urlString = new StringBuffer(MAPQUEST_GUIDANCE_SERVICE);
		urlString.append("from=");
		GeoPoint p = waypoints.get(0);
		urlString.append(geoPointAsString(p));
		
		for (int i=1; i<waypoints.size(); i++){
			p = waypoints.get(i);
			urlString.append("&to="+geoPointAsString(p));
		}
		
		urlString.append("&outFormat=xml");
		urlString.append("&shapeFormat=cmp"); //encoded polyline, much faster
		
		urlString.append("&narrativeType=text"); //or "none"
		Locale locale = Locale.getDefault();
		urlString.append("&locale="+locale.getLanguage()+"_"+locale.getCountry());
		
		urlString.append("&unit=k&fishbone=false");
		
		//urlString.append("&generalizeAfter=500" /*+&generalize=2"*/); 
			//500 points max, 2 meters tolerance
		
		//Warning: MapQuest Open API doc is sometimes WRONG:
		//- use unit, not units
		//- use fishbone, not enableFishbone
		//- locale (fr_FR, en_US) is supported but not documented. 
		//- generalize and generalizeAfter are not properly implemented
		urlString.append(mOptions);
		return urlString.toString();
	}
	
	/**
	 * @param waypoints: list of GeoPoints. Must have at least 2 entries, start and end points. 
	 * @return the road
	 */
	public Road getRoad(ArrayList<GeoPoint> waypoints) {
		String url = getUrl(waypoints);
		Log.d(BonusPackHelper.LOG_TAG, "MapQuestRoadManager.getRoute:"+url);
		Road road = null;
		HttpConnection connection = new HttpConnection();
		connection.doGet(url);
		InputStream stream = connection.getStream();
		if (stream != null)
				road = getRoadXML(stream);
		connection.close();
		if (road == null || road.mRouteHigh.size()==0){
			//Create default road:
			road = new Road(waypoints);
		} else {
			road.finalizeNodes();
			road.buildLegs(waypoints);
		}
		return road;
	}

	/** 
	 * XML implementation
	 * @param is: input stream to parse
	 * @return the road
	 */
	protected Road getRoadXML(InputStream is) {
		XMLHandler handler = new XMLHandler();
		try {
			SAXParser parser = SAXParserFactory.newInstance().newSAXParser();
			parser.parse(is, handler);
		} catch (ParserConfigurationException e) {
			e.printStackTrace();
		} catch (SAXException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return handler.mRoad;
	}
	
}


/** XMLHandler: class to handle XML generated by MapQuest "guidance" open API. 
 *
 */
class XMLHandler extends DefaultHandler {
	Road mRoad;
	boolean isBB;
	boolean isGuidanceNodeCollection;
	private String mString;
	double mLat, mLng;
	double mNorth, mWest, mSouth, mEast;
	RoadLink mLink;
	RoadNode mNode;
	
	public XMLHandler() {
		isBB = isGuidanceNodeCollection = false;
		mRoad = new Road();
	}

	public void startElement(String uri, String localName, String name,
			Attributes attributes) throws SAXException {		
		if (localName.equals("boundingBox"))
			isBB = true;
		else if (localName.equals("link"))
			mLink = new RoadLink();
		else if (localName.equals("node"))
			mNode = new RoadNode();
		else if (localName.equals("GuidanceNodeCollection"))
			isGuidanceNodeCollection = true;
		mString = new String();
	}

	/**
	 * Overrides org.xml.sax.helpers.DefaultHandler#characters(char[], int, int)
	 */
	public void characters(char[] ch, int start, int length)
			throws SAXException {
			String chars = new String(ch, start, length);
			mString = mString.concat(chars);
	}
	
	public void endElement(String uri, String localName, String name)
	throws SAXException {
		if (localName.equals("lat")) {
			mLat = Double.parseDouble(mString);
		} else if (localName.equals("lng")) {
			mLng = Double.parseDouble(mString);
		} else if (localName.equals("shapePoints")) {
			mRoad.mRouteHigh = PolylineEncoder.decode(mString, 10);
			//Log.d("DD", "High="+mRoad.mRouteHigh.size());
		} else if (localName.equals("generalizedShape")) {
			mRoad.setRouteLow(PolylineEncoder.decode(mString, 10));
			//Log.d("DD", "Low="+mRoad.mRouteLow.size());
		} else if (localName.equals("length")) {
			mLink.mLength = Double.parseDouble(mString);
		} else if (localName.equals("speed")) {
			mLink.mSpeed = Double.parseDouble(mString);
		} else if (localName.equals("shapeIndex")){
			mLink.mShapeIndex = Integer.parseInt(mString);
		} else if (localName.equals("link")) {
			//End of a link: update road attributes:
			//GuidanceLinkCollection could in theory contain additional unused links, 
			//but normally not with fishbone set to false. 
			mLink.mDuration = mLink.mLength / mLink.mSpeed * 3600.0;
			mRoad.mLinks.add(mLink);
			mRoad.mLength += mLink.mLength;
			mRoad.mDuration += mLink.mDuration;
			mLink = null;
		} else if (localName.equals("turnCost")){
			int turnCost = Integer.parseInt(mString);
			mNode.mDuration += turnCost;
			mRoad.mDuration += turnCost;
		} else if (localName.equals("maneuverType")){
			mNode.mManeuverType = Integer.parseInt(mString);
		} else if (localName.equals("info")){
			if (isGuidanceNodeCollection){
				if (mNode.mInstructions == null) 
					//this is first "info" value for this node, keep it:
					mNode.mInstructions = mString;
			}
		} else if (localName.equals("linkId")){
			if (isGuidanceNodeCollection)
				mNode.mNextRoadLink = Integer.parseInt(mString);
		} else if (localName.equals("node")){
			mRoad.mNodes.add(mNode);
			mNode = null;
		} else if (localName.equals("GuidanceNodeCollection")){
			isGuidanceNodeCollection = false;
		} else if (localName.equals("ul")){
			if (isBB){
				mNorth = mLat;
				mWest = mLng;
			}
		} else if (localName.equals("lr")){
			if (isBB){
				mSouth = mLat;
				mEast = mLng;
			}
		} else if (localName.equals("boundingBox")){
			mRoad.mBoundingBox = new BoundingBoxE6(mNorth, mEast, mSouth, mWest);
			isBB = false;
		}
	}
}
